
		TOPPERS/SafeG
		デバッグTipsマニュアル

		対応バージョン: Release 1.2.2
		最終更新: 2015年09月17日

本ドキュメントは,SafeGを用いたシステム実装時の注意点や特有のデバッグ方
法について記述したものである.本マニュアルはSafeGの基本的なアーキテクチ
ャについては理解した上で読むことを前提としている.SafeGの詳細については 
doc/user.txtを参照のこと．

ポーティングの方法については fmp_porting.txtを合わせて読むこと.

【ポーティングとデバッグの流れ】

SafeGでは,以下の順にOSの起動を行う.マルチコアの場合も各コアで同様の処
理が行われる.

1. SafeGの起動 (モニタモード)
2. RTOSの起動 (セキュア状態)
3. 汎用OSの起動 (ノンセキュア状態)

ここではRTOS=FMPカーネル,汎用OS=Linuxとして解説する.

SafeGのターゲットへのポーティングを行う場合は,まず上記1から2の処理が正
しくおこなわれることを確認するべきである.すなわち,SafeGの初期化処理が
適切に行われ,その後にFMPカーネルのエントリーポイントにジャンプすること
ができているかを確認する. FMPカーネルのコードにセキュア状態でアクセス
することが出来れば,それ以降の動作はFMPカーネルのみをターゲットで動作さ
せているのに近い状況で動作確認ができる. (この状態でFMPカーネルのみで動
作させるのと大きな違いは,FMPカーネルの割り込みがFIQで入力され,SafeGで
一旦ハンドリングされることである.)

汎用OSの起動に移る際は,RTOSからsmc命令を実行する必要がある.このため
,smc命令を発行するコードをFMPカーネルに組込まない限りは,上記3のステッ
プに進むことはない.この段階でRTOSがSafeG上で動作していることを確認する.
その際,とくに割り込みについて以下のような点に注意すべきである.

・モニタモードのベクタテーブルが登録されているか
・FMPカーネルの使用しているデバイスの割り込みがFIQで入力されているか
・FIQがSafeGのfiq_handlerで一旦ハンドリングされた後,
  FMPカーネルのirq_handlerにジャンプしているか

FMPカーネルがSafeG上で正しく動作していることを確認したら,smc命令を発行
するコードを入れる.smc命令はFMPカーネルがアイドルとなった場合に実行さ
れるようにするため,実装方法としては以下の2つの方法が考えられる.

 (1) FMPカーネル上で動作する最低優先度のタスクでsmc実行
 (2) FMPカーネルの割り込み待ちのコード中でsmc実行

(1)の方法では,最低優先度タスク内でsafeg_syscall_switch()システムコール
をを実行する.

smc命令を発行した時点で3のステップ(Linuxの起動)に移る.Linuxは,ブートロ
ーダ(u-boot等)により必要なデバイスの初期化が行われた後に起動処理が行わ
れる.このため,上記3ではu-bootが起動され,そのu-bootからLinuxが起動され
る点に注意が必要である.また,Linuxの起動中にFMPカーネルで使用するデバイ
スから割り込みが発生した場合には,SafeGによりOS切り替えが行われ,FMPカー
ネルに処理がうつる.Linuxの起動ができることを確認するまで,FMPカーネル側
の割り込みは無効にしておくべきである.これにより,単純にLinuxをノンセキ
ュア状態のプロセッサで実行した場合についてポーティングを進めることがで
きる.

マルチコアの場合は，こうしたシングルコアでの動作確認を最初に行う．シン
グルコアでOSの動作を確認したら,SafeGと2つのOSをマルチコアプロセッサ向
けに構成しなおして実装を進める.各コアでSafeGが正しく動作していれば,各
OSの設定を大きく変更する必要はない.ただしsmc命令をタスク内で実行するよ
うにした場合,すべてのコアにsmc命令を発行するタスクを配置する必要がある.


【デバッガによるデバッグ】
SafeGのコードをデバッグするためには，デバッガがTrustZoneをサポートして
いる必要がある．

<割込みの流れを追う>
SafeGポーティング時に障害となりやすいのが割込みのセキュリティ設定ミス
である．正しく割込みが動作していることを確認するのにデバッガは有効であ
る．

RTOSの割込みが正しく動作していることを確認するために以下のステップを踏
むとよい．

・RTOSで動作確認したい割込み以外の割込みを無効とする．
・SafeGのfiq_handlerにブレークポイントを設定し，RTOSの割込み発生時にブ
  レークされるか確認する．
・ブレーク後にステップ実行を行い，fiq_exitからRTOSのirq_handlerにジャ
  ンプするか確認する．

同様に汎用OSの割込みがSafeGのirq_handlerでハンドリングされるか，各OSか
ら発行されたsmc例外がSafeGのsmc_handlerでハンドリングされるかを確認す
る．

<セキュア/ノンセキュア状態の確認>
TrustZoneに対応したデバッガでは，現在実行中のコードがセキュアまたはノ
ンセキュア状態で実行されているかを確認できるものがある．これによりRTOS
のコードがセキュア状態で，汎用OSのコードがノンセキュア状態で実行されて
いるかを確認できる．

<レジスタの値>
通常のデバッガによるデバッグと同様に，SafeGを用いた場合でも，問題発生
時のレジスタの値は多くのヒントを含んでいる．とくにデータアボート等の例
外が発生した場合のLRの値を確認することで，どの命令がその例外を引き起こ
したかを確認できる．アボート例外ではノンセキュア側がセキュア専用命令を
実行した，セキュア側デバイスへアクセス違反をしたなどを最初に疑うべきで
ある．


【smcを使用したノンセキュア側のデバッグ】
Linuxが起動しない場合などに，どこまで実行が進んでいるかを確認するため
に有効である. (デバッガが使用できない場合にも有効なデバッグ方法である)
ノンセキュア側からsmc命令を発行すると,SafeGのsmc_handlerを経由して強制
的にOS切り替えが行われる.このため,Linuxの起動コード中にsmc命令を挿入し
た状態でSafeGを用いて実行すれば,Linuxの起動コードが正しく実行されてい
れば,Linux起動後にRTOSに強制的にリターンするはずである.もしRTOS側にリ
ターンしなかった場合は,smc命令を埋め込んだところまでLinuxの起動処理が
進んでいない可能性が高い.

<Linux中でRTOSにリターンするための関数>
safeg_syscall_switch();


【RTOS側で発生した例外を利用したデバッグ】
SafeGの構造上，汎用OSが停止してもRTOSは動作し続けることが可能である．
また，汎用OSの引き起こした問題がRTOSへ例外として通知されるかもしれない．
この例外はデバッグに有用な情報を含むことが多い．

例えば，SafeGに対応したRTOSの一つであるFMPカーネルでは，例外フレームを
用いて例外発生時のレジスタの情報をダンプすることができる．このため，デ
バッガが使用できない状況でも例外を引き起こした番地などを知ることができ
る．

【Linuxのearlryprintkによるデバッグ】
Linuxではカーネルメッセージをprintkを用いたデバッグが可能である．しか
し，ポーティング作業中等では，Linuxのブート処理中にカーネルが停止する
場合が多い．この場合，シリアルポートの初期化が完全に終了するまで，
printkの出力が得られない可能性が高い．こうしたケースではLinuxの
earlryprintk機能を使ったデバッグが有効である．この機能を用いることで，
早い段階でシリアルポートの低レベル出力が初期化され，ブート処理中であっ
てもprintkの出力が得られるようになる．earlryprintk機能を利用するにはカ
ーネルとカーネルパラメータを変更する必要がある．

1. カーネルのearlyprintk機能を有効にしてリビルド
	Kernel hacking
		-> Kernel low-level debugging functions
			-> Early printk
2. u-bootのbootargsにearlyprintkを追加
UBOOT > set bootargs $(bootargs), earlyprintk=ttyS0,115200



【各種トラブルシューティング】

<マルチコア構成でRTOS起動後に止まる>
各OSとSafeGで同じコア数を指定しているか確認する．とくにRTOSまで進む場
合OS切り替え時以降で動作が停止している可能性が高いため，SafeGのコア数
指定が誤っていると考えられる．

<RTOSが起動しない>
SafeGで指定している,OSのエントリポイントのアドレスが誤っているケースが
考えられる.

<汎用OSが起動しない>
SafeGで指定している,OSのエントリポイントのアドレスが誤っているケースが
考えられる.また,RTOSからsmc命令が発行されていない,またはSafeGのsmcハン
ドラにジャンプできていない.マルチコアの場合は全てのコアでsmc命令が発行
されているか確認する.

<RTOS起動後にu-bootは起動するが,Linuxが起動しない>
Linuxの起動処理がどこまで行われているか確認する.Linuxの起動ログが全く
出力されていなくても,途中まで処理が進んでいる可能性がある.起動後に
,RTOS側で例外が発生する場合はアクセス違反のデバイスを初期化(例えば,L2
キャッシュコントローラ)していると考えられる.

マルチコアの場合は,u-bootはマスタコアのみで動作していてもシリアルポー
トに出力が現れるため,正しく動作しているように見えることがあるが,実際は
セカンダリコア以降がu-bootを実行していない可能性がある.全てのコアでsmc
を発行しているか確認する.

特にLinuxの場合，コア間割込み(IPI)が正しく動作しているかを確認する．コ
ア間割込みが動作しない理由として，割込みセキュリティの設定ミス及び割込
み優先度の設定ミスが考えられる．fmp_porting.txtの<Linuxにおけるプライ
ベート割込み(SGI, PPI)の優先度設定>も参照．

<RTOSでspurious割り込み(割り込み番号1022番)が発生する>
TrustZone実行時には,割り込み番号1022の割り込みが発生する.この割り込み
は,ノンセキュア側の割り込み優先度がセキュア側の割り込み優先度より高い
場合に発生する.spurious割り込みが発生した場合は,割り込み優先度の設定
(特に,ノンセキュア側)がFMPカーネルで適切に行われていない可能性が高い
.SGIとPPIについては全てのコアで優先度設定が行われているか確認すること.

以上．
